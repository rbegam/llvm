//===--- IntelAttr.td - Intel attribute definitions -----------------------===//
//
// Copyright (C) 2017 Intel Corporation. All rights reserved.
//
// The information and source code contained herein is the exclusive
// property of Intel Corporation and may not be disclosed, examined
// or reproduced in whole or in part without explicit written authorization
// from the company.
//
//===----------------------------------------------------------------------===//

include "clang/Basic/intel/IntelAttrDocs.td"

class SourceLocArgument<string name, bit opt = 0> : Argument<name, opt>;
class CheckedExprArgument<string name> : Argument<name, 1>;

def AvoidFalseShare : InheritableAttr {
  let Spellings = [Declspec<"avoid_false_share">];
  let Args = [StringArgument<"ExceptionId">];
  let HasCustomParsing = 1;
  let Documentation = [Undocumented];
  int Requires = 4;
}

def Allocate : InheritableAttr {
  let Spellings = [GNU<"allocate">];
  let Args = [StringArgument<"Name">];
  let HasCustomParsing = 1;
  let Documentation = [Undocumented];
  int Requires = 4;
}

def GCCStruct : InheritableAttr {
  let Spellings = [GNU<"gcc_struct">];
  let Subjects = SubjectList<[Record]>;
  let HasCustomParsing = 1;
  let Documentation = [Undocumented];
  int Requires = 4;
}

def BNDLegacy : InheritableAttr {
  let Spellings = [GNU<"bnd_legacy">];
  let Subjects = SubjectList<[Function]>;
  let Documentation = [Undocumented];
  int Requires = 4;
}

def BNDVarSize : InheritableAttr {
  let Spellings = [GNU<"bnd_variable_size">];
  let Subjects = SubjectList<[Field], WarnDiag,
                             "ExpectedFieldOrGlobalVar">;
  let Documentation = [Undocumented];
  int Requires = 4;
}

def Leaf : IgnoredAttr {
  let Spellings = [GNU<"leaf">];
  let Subjects = SubjectList<[Function]>;
}

def IntelInline : Attr {
  let Spellings = [Pragma<"", "inline">, Pragma<"", "forceinline">,
                   Pragma<"", "noinline">];
  let Args =  [EnumArgument<"Option", "OptionType",
                           ["recursive", "<unspecified>"],
                           ["Recursive", "NotRecursive"]>];
  let AdditionalMembers = [{
  void printPrettyPragma(raw_ostream &OS, const PrintingPolicy &Policy) const {
    OS << getDiagnosticName(Policy);
  }
  std::string getDiagnosticName(const PrintingPolicy &Policy) const {
    unsigned SpellingIndex = getSpellingListIndex();
    if (SpellingIndex == Pragma_inline)
      return "#pragma inline";
    else if (SpellingIndex == Pragma_forceinline)
      return "#pragma forceinline";
    else
      return "#pragma noinline";
  }
  }];
  let Documentation = [Undocumented];
}

// FPGA-specific attributes

def OpenCLBlocking : Attr {
  let Spellings = [GNU<"blocking">];
  let Subjects = SubjectList<[Var]>;
  let Documentation = [OpenCLBlockingDocs];
  let LangOpts = [OpenCL];
}

def OpenCLDepth : Attr {
  let Spellings = [GNU<"depth">];
  let Args = [UnsignedArgument<"Depth">];
  let Subjects = SubjectList<[ParmVar, GlobalVar]>;
  let Documentation = [OpenCLDepthDocs];
  let LangOpts = [OpenCL];
}

def OpenCLIO : Attr {
  let Spellings = [GNU<"io">];
  let Args = [StringArgument<"IOName">];
  let Subjects = SubjectList<[Var]>;
  let Documentation = [OpenCLIODocs];
  let LangOpts = [OpenCL];
}

def HLS : LangOpt<"HLS">;

def OpenCLLocalMemSize : Attr {
  let Spellings = [GNU<"local_mem_size">];
  let Args = [UnsignedArgument<"LocalMemSize">];
  let Subjects = SubjectList<[ParmVar], ErrorDiag>;
// FIXME: Add documentation
  let Documentation = [Undocumented];
  let LangOpts = [OpenCL, HLS];
}

def OpenCLBufferLocation : Attr {
  let Spellings = [GNU<"buffer_location">];
  let Args = [StringArgument<"BufferLocation">];
  let Subjects = SubjectList<[ParmVar], ErrorDiag>;
  let Documentation = [OpenCLBufferLocationDocs];
  let LangOpts = [OpenCL];
}

def MaxWorkGroupSize : InheritableAttr {
  let Spellings = [GNU<"max_work_group_size">];
  let Args = [UnsignedArgument<"XDim">, UnsignedArgument<"YDim">,
              UnsignedArgument<"ZDim">];
  let Subjects = SubjectList<[Function]>;
// FIXME: Add documentation
  let Documentation = [Undocumented];
}

def NumComputeUnits : InheritableAttr {
  let Spellings = [GNU<"num_compute_units">];
  let LangOpts = [OpenCL];
  let Args = [IntArgument<"XDim">, DefaultIntArgument<"YDim", 1>,
              DefaultIntArgument<"ZDim", 1>];
  let Subjects = SubjectList<[Function]>;
  let Documentation = [NumComputeUnitsDocs];
}

def NumSimdWorkItems : InheritableAttr {
  let Spellings = [GNU<"num_simd_work_items">];
  let Args = [UnsignedArgument<"NumSimdWorkItems">];
  let Subjects = SubjectList<[Function]>;
// FIXME: Add documentation
  let Documentation = [Undocumented];
}

def MaxGlobalWorkDim : InheritableAttr {
  let Spellings = [GNU<"max_global_work_dim">];
  let LangOpts = [OpenCL];
  let Args = [UnsignedArgument<"MaxGlobalWorkDimValue">];
  let Subjects = SubjectList<[Function]>;
  let Documentation = [MaxGlobalWorkDimDocs];
}

def Autorun : InheritableAttr {
  let Spellings = [GNU<"autorun">];
  let LangOpts = [OpenCL];
  let Subjects = SubjectList<[Function]>;
  let Documentation = [AutorunDocs];
}

def OpenCLHostAccessible : Attr {
  let Spellings = [GNU<"intel_host_accessible">];
  let Subjects = SubjectList<[Var]>;
  let Documentation = [OpenCLHostAccessibleDocs];
  let LangOpts = [OpenCL];
}

// End of FPGA-specific attributes

def VecLenHint : InheritableAttr {
  let Spellings = [GNU<"intel_vec_len_hint">];
  let Args = [UnsignedArgument<"VecLen">];
  let Subjects = SubjectList<[Function], ErrorDiag>;
  let Documentation = [VecLenHintDocs];
}

// HLS function attributes
def Component : InheritableAttr {
  let Spellings = [GNU<"ihc_component">];
  let LangOpts = [HLS];
  let Subjects = SubjectList<[Function], ErrorDiag>;
  let Documentation = [Undocumented];
}

def ComponentInterface : InheritableAttr {
  let Spellings = [GNU<"component_interface">];
  // If adding to the end of enum, modify generateValidStrings as well.
  let Args = [EnumArgument<"Type", "ComponentInterfaceType",
                           ["avalon_streaming", "avalon_mm_slave",
                            "always_run"],
                           ["Streaming", "Slave", "AlwaysRun"]>];
  let LangOpts = [HLS];
  let Subjects = SubjectList<[Function], ErrorDiag>;
  let Documentation = [Undocumented];
  let AdditionalMembers = [{
    static void generateValidStrings(SmallString<256> &Str) {
      auto Last = AlwaysRun;
      for (int I = 0; I <= Last; ++I) {
        Str += ConvertComponentInterfaceTypeToStr(
                static_cast<ComponentInterfaceType>(I));
        if (I != Last) Str += " ";
      }
    }
  }];
}

def MaxConcurrency : InheritableAttr {
  let Spellings = [GNU<"max_concurrency">];
  let Args = [ExprArgument<"Max">];
  let LangOpts = [OpenCL, HLS];
  let Subjects = SubjectList<[Function], ErrorDiag>;
  let Documentation = [Undocumented];
  let AdditionalMembers = [{
    static unsigned getMinValue() {
      return 0;
    }
    static unsigned getMaxValue() {
      return 1024*1024;
    }
  }];
}

def StallFreeReturn : InheritableAttr {
  let Spellings = [GNU<"stall_free_return">];
  let LangOpts = [HLS];
  let Subjects = SubjectList<[Function], ErrorDiag>;
  let Documentation = [Undocumented];
}

def UseSingleClock : InheritableAttr {
  let Spellings = [GNU<"hls_component_use_single_clock">];
  let LangOpts = [HLS];
  let Subjects = SubjectList<[Function], ErrorDiag>;
  let Documentation = [Undocumented];
}

// HLS parameter attributes
def ArgumentInterface : Attr {
  let Spellings = [GNU<"argument_interface">];
  // If adding to the end of enum, modify generateValidStrings as well.
  let Args = [EnumArgument<"Type", "ArgumentInterfaceType",
                           ["wire","avalon_mm_slave", "avalon_streaming"],
                           ["Wire", "Slave", "Streaming"]>];
  let Subjects = SubjectList<[ParmVar], ErrorDiag>;
  let LangOpts = [HLS];
  let Documentation = [Undocumented];
  let AdditionalMembers = [{
    static void generateValidStrings(SmallString<256> &Str) {
      auto Last = Streaming;
      for (int I = 0; I <= Last; ++I) {
        Str += ConvertArgumentInterfaceTypeToStr(
                static_cast<ArgumentInterfaceType>(I));
        if (I != Last) Str += " ";
      }
    }
  }];
}

def StableArgument : Attr {
  let Spellings = [GNU<"stable_argument">];
  let Subjects = SubjectList<[ParmVar], ErrorDiag>;
  let LangOpts = [HLS];
  let Documentation = [Undocumented];
}

def SlaveMemoryArgument : Attr {
  let Spellings = [GNU<"slave_memory_argument">];
  let Subjects = SubjectList<[ParmVar], ErrorDiag>;
  let LangOpts = [HLS];
  let Documentation = [Undocumented];
}

// HLS local or static variable attributes

def HLSLocalOrStaticVar : SubsetSubject<Var,
                              [{S->getKind() != Decl::ImplicitParam &&
                                S->getKind() != Decl::ParmVar &&
                                S->getKind() != Decl::NonTypeTemplateParm &&
                                (S->getStorageClass() == SC_Static ||
                                 S->hasLocalStorage())}],
                              "local or static variables">;
// No arguments.
def SinglePump : Attr {
  let Spellings = [GNU<"singlepump">];
  let Subjects = SubjectList<[HLSLocalOrStaticVar], ErrorDiag>;
  let LangOpts = [OpenCL, HLS];
  let Documentation = [Undocumented];
}

def DoublePump : Attr {
  let Spellings = [GNU<"doublepump">];
  let Subjects = SubjectList<[HLSLocalOrStaticVar], ErrorDiag>;
  let LangOpts = [OpenCL, HLS];
  let Documentation = [Undocumented];
}

def Memory : Attr {
  let Spellings = [GNU<"memory">];
  let Args = [EnumArgument<"Kind", "MemoryKind",
                           ["MLAB", "BLOCK_RAM", ""],
                           ["MLAB", "BlockRAM", "Default"], 1>];
  let AdditionalMembers = [{
    static void generateValidStrings(SmallString<256> &Str) {
      auto Last = BlockRAM;
      for (int I = 0; I <= Last; ++I) {
        Str += ConvertMemoryKindToStr(static_cast<MemoryKind>(I));
        if (I != Last) Str += " ";
      }
    }
  }];
  let Subjects = SubjectList<[HLSLocalOrStaticVar], ErrorDiag>;
  let LangOpts = [OpenCL, HLS];
  let Documentation = [Undocumented];
}

def Register : Attr {
  let Spellings = [GNU<"register">];
  let Subjects = SubjectList<[HLSLocalOrStaticVar], ErrorDiag>;
  let LangOpts = [OpenCL, HLS];
  let Documentation = [Undocumented];
}

// One integral argument.
def BankWidth : Attr {
  let Spellings = [GNU<"bankwidth">];
  let Args = [ExprArgument<"Value">];
  let Subjects = SubjectList<[HLSLocalOrStaticVar], ErrorDiag>;
  let LangOpts = [OpenCL, HLS];
  let Documentation = [Undocumented];
  let AdditionalMembers = [{
    static unsigned getMinValue() {
      return 1;
    }
    static unsigned getMaxValue() {
      return 1024*1024;
    }
  }];
}

def NumBanks : Attr {
  let Spellings = [GNU<"numbanks">];
  let Args = [ExprArgument<"Value">];
  let Subjects = SubjectList<[HLSLocalOrStaticVar], ErrorDiag>;
  let LangOpts = [OpenCL, HLS];
  let Documentation = [Undocumented];
  let AdditionalMembers = [{
    static unsigned getMinValue() {
      return 1;
    }
    static unsigned getMaxValue() {
      return 1024*1024;
    }
  }];
}

def NumReadPorts : Attr {
  let Spellings = [GNU<"numreadports">];
  let Args = [ExprArgument<"Value">];
  let Subjects = SubjectList<[HLSLocalOrStaticVar], ErrorDiag>;
  let LangOpts = [OpenCL, HLS];
  let Documentation = [Undocumented];
  let AdditionalMembers = [{
    static unsigned getMinValue() {
      return 1;
    }
    static unsigned getMaxValue() {
      return 1024*1024;
    }
  }];
}

def NumWritePorts : Attr {
  let Spellings = [GNU<"numwriteports">];
  let Args = [ExprArgument<"Value">];
  let Subjects = SubjectList<[HLSLocalOrStaticVar], ErrorDiag>;
  let LangOpts = [OpenCL, HLS];
  let Documentation = [Undocumented];
  let AdditionalMembers = [{
    static unsigned getMinValue() {
      return 1;
    }
    static unsigned getMaxValue() {
      return 1024*1024;
    }
  }];
}

// Two integral arguments.
def NumPortsReadOnlyWriteOnly : Attr {
  let Spellings = [GNU<"numports_readonly_writeonly">];
  let Args = [ExprArgument<"NumReadPorts">, ExprArgument<"NumWritePorts">];
  let Subjects = SubjectList<[HLSLocalOrStaticVar], ErrorDiag>;
  let LangOpts = [OpenCL, HLS];
  let Documentation = [Undocumented];
  let AdditionalMembers = [{
    static unsigned getMinValue() {
      return 1;
    }
    static unsigned getMaxValue() {
      return 1024*1024;
    }
  }];
}

// Two string arguments.
def Merge : Attr {
  let Spellings = [GNU<"merge">];
  let Args = [StringArgument<"Name">, StringArgument<"Direction">];
  let Subjects = SubjectList<[HLSLocalOrStaticVar], ErrorDiag>;
  let LangOpts = [OpenCL, HLS];
  let Documentation = [Undocumented];
}

// Variadic integral arguments.
def BankBits : Attr {
  let Spellings = [GNU<"bank_bits">];
  let Args = [VariadicExprArgument<"Args">];
  let Subjects = SubjectList<[HLSLocalOrStaticVar], ErrorDiag>;
  let LangOpts = [OpenCL, HLS];
  let Documentation = [Undocumented];
  let AdditionalMembers = [{
    static unsigned getMinValue() {
      return 1;
    }
    static unsigned getMaxValue() {
      return 1024*1024;
    }
  }];
}

def HLSLocalStaticVar : SubsetSubject<Var,
                              [{S->getStorageClass() == SC_Static &&
                                S->getKind() != Decl::ImplicitParam &&
                                S->getKind() != Decl::ParmVar &&
                                S->getKind() != Decl::NonTypeTemplateParm}],
                              "local static variables">;

// One integral argument, static only.
def StaticArrayReset : Attr {
  let Spellings = [GNU<"static_array_reset">];
  let Args = [ExprArgument<"Value">];
  let Subjects = SubjectList<[HLSLocalStaticVar], ErrorDiag>;
  let LangOpts = [HLS];
  let Documentation = [Undocumented];
  let AdditionalMembers = [{
    static unsigned getMinValue() {
      return 0;
    }
    static unsigned getMaxValue() {
      return 1;
    }
  }];
}
