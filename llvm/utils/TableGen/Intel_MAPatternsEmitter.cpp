//
//      Copyright (c) 2016 Intel Corporation.
//      All rights reserved.
//
//        INTEL CORPORATION PROPRIETARY INFORMATION
//
// This software is supplied under the terms of a license
// agreement or nondisclosure agreement with Intel Corp.
// and may not be copied or disclosed except in accordance
// with the terms of that agreement.
//
// static char cvs_id[] = "$Id$";
//
// This tablegen backend is responsible for emitting efficient MUL/ADD/FMA
// patterns for the target code generator. The main purpose of having this
// backend is to do the most expensive part of the efficient MUL/ADD/FMA
// auto-generation work to the compiler build phase and to let code generator
// quickly find pre-computed efficient alternatives/patterns for the input
// expressions.
//
//  External interfaces:
//      void EmitMAPatterns(RecordKeeper &RK, raw_ostream &OS);
//

#include "CodeGenTarget.h"
#include "llvm/Support/Format.h"
#include "llvm/TableGen/Error.h"
#include "llvm/TableGen/Record.h"
#include "llvm/TableGen/TableGenBackend.h"

using namespace llvm;

#define DEBUG_TYPE "x86-global-ma"
#include "llvm/Support/Debug.h"

#include "../../lib/Target/X86/Intel_X86FMACommon.h"

namespace {


// This enum defines known MUL/ADD-like operations that could be used by this
// tablegen. If the target platform supports some or all of those and such
// operation need to be used here then the target description file must
// contain corresponding definitions/instances of 'MAOperation' class.
//
// Potentially some new operations can be added to this enum if expressions
// with such expression can be transformed to a canonic form having only
// MUL and ADD operations.
enum MAOperation {
  ADD = 0, // A + B
  MUL = 1, // A * B
  FMA = 2, // A * B + C
  MAOperationsNum = 3
};

// Describes the known operations.
typedef struct MAOperationDesc {
  MAOperation Index;
  bool        IsSupported;
  const char  *Name;
  const char  *Description;
} MAOperationDesc;

class MAPatternsEmitter {
  RecordKeeper &Records;
private:
  // Parse the input Target Description files, find the supported MUL/ADD/etc
  // operations and configure the patterns emitter.
  void parseTDAndConfigurePatternsEmitter(raw_ostream &OS,
                                          MAOperationDesc AllMAOperations[]);

  // Emit X86MA patters emitter for X86 target.
  void emitX86Patterns(raw_ostream &OS, MAOperationDesc AllMAOperations[]);

public:
  MAPatternsEmitter(RecordKeeper &R) : Records(R) {}

  // Output the MA patterns for the target code generator.
  void run(raw_ostream &OS);
};
} // End anonymous namespace

// Parses the input target description files and looks for the definitions
// of the class 'MAOperation' and instances of that class. Such instances
// define the MULL/ADD-like operations available in the target and let this
// tablegen using them.
void
MAPatternsEmitter::parseTDAndConfigurePatternsEmitter(
                       raw_ostream &OS,
                       MAOperationDesc AllMAOperations[]) {

  // Print the enumarator with all known MUL/ADD operations.
  OS << "// The following operations are known by this tablegen and\n"
        "// potentially can be generated by this patterns emitter:\n";
  for (unsigned OpInd = 0; OpInd < MAOperationsNum; OpInd++) {
    OS << "//   " << std::string(AllMAOperations[OpInd].Name)
       << " : MAOperation<" << OpInd << ">; // "
       << std::string(AllMAOperations[OpInd].Description) << "\n";
  }

  // Check if the the class MAOperation is defined, exit if it is not.
  Record *MAOperationClass = Records.getClass("MAOperation");
  if (!MAOperationClass) {
    OS << "//\n"
          "// The target does not define the class MAOperation \n"
          "// and thus it does not define any MUL/ADD/FMA operations.\n"
          "//\n";
    return;
  }

  // Find the MA operations, i.e. instances of MAOperation class.
  // Set the 'IsSupported' field to true when found supported instances.
  // The found operations are not emitted right here to avoid duplications
  // and to print them only after sort by the value of the 'Index' field.
  for (const auto &D : Records.getDefs()) {
    if (D.second->isSubClassOf(MAOperationClass)) {
      unsigned Val = D.second->getValueAsInt("Index");
      if (Val >= MAOperationsNum)
        OS << "\n!Warning: Found an unexpected MAOperation.\n\n";
      else
        AllMAOperations[Val].IsSupported = true;
    }
  }

  // Print the MA operations available in the target platform.
  OS << "\n// The following operations are available in the target platform:\n";
  for (unsigned OpInd = 0; OpInd < MAOperationsNum; OpInd++) {
    if (AllMAOperations[OpInd].IsSupported)
      OS << "//   " << std::string(AllMAOperations[OpInd].Name) << "\n";
  }
}

void
MAPatternsEmitter::emitX86Patterns(raw_ostream &OS,
                                   MAOperationDesc AllMAOperations[]) {

  // FIXME: We cannot proceed without ADD/MUL/FMA operations.
  // It should be possible to relax this constraint later, for example,
  // generate patterns when only ADD and MUL operations are available.
  if (!AllMAOperations[ADD].IsSupported ||
      !AllMAOperations[MUL].IsSupported ||
      !AllMAOperations[FMA].IsSupported) {
    OS << "\n\n// Warning: Cannot generate patterns without "
          "ADD/MUL/FMA operations!\n";
    return;
  }

  // TODO: Generate and emit MA patterns here.
}

void MAPatternsEmitter::run(raw_ostream &OS) {
  CodeGenTarget Target(Records);

  emitSourceFileHeader("MA Patterns Header Fragment", OS);

  MAOperationDesc AllMAOperations[] = {
    {ADD, false, "MAOperationADD", "ADD: A + B"},
    {MUL, false, "MAOperationMUL", "MUL: A * B"},
    {FMA, false, "MAOperationFMA", "FMA: A * B + C"}
  };
  parseTDAndConfigurePatternsEmitter(OS, AllMAOperations);

  // Target.getName returns an object of the type string.
  // So, it is ok to use '==' operation below.
  if (Target.getName() == "X86")
    emitX86Patterns(OS, AllMAOperations);
}

namespace llvm {

void EmitMAPatterns(RecordKeeper &RK, raw_ostream &OS) {
  MAPatternsEmitter(RK).run(OS);
}

} // End llvm namespace
