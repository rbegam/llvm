; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=x86_64-unknown-unknown -mattr=bmi | FileCheck %s

; Test that we use an TZCNT+AND to remove the select and icmp.

declare i32 @llvm.cttz.i32(i32, i1)

define i32 @icmp(i32 %x) {
; CHECK-LABEL: icmp:
; CHECK:       # %bb.0:
; CHECK-NEXT:    tzcntl %edi, %eax
; CHECK-NEXT:    andl $31, %eax
; CHECK-NEXT:    retq
  %a = icmp eq i32 %x, 0
  %b = call i32 @llvm.cttz.i32(i32 %x, i1 true)
  %c = select i1 %a, i32 0, i32 %b
  ret i32 %c
}

define i32 @subo1(i32 %x, i32* %y) {
; CHECK-LABEL: subo1:
; CHECK:       # %bb.0:
; CHECK-NEXT:    tzcntl %edi, %eax
; CHECK-NEXT:    decl %edi
; CHECK-NEXT:    andl $31, %eax
; CHECK-NEXT:    movl %edi, (%rsi)
; CHECK-NEXT:    retq
  %a = icmp eq i32 %x, 0
  %b = call i32 @llvm.cttz.i32(i32 %x, i1 true)
  %c = select i1 %a, i32 0, i32 %b
  %d = sub i32 %x, 1
  store i32 %d, i32* %y
  ret i32 %c
}

define i32 @subo2(i32 %x, i32* %y) {
; CHECK-LABEL: subo2:
; CHECK:       # %bb.0:
; CHECK-NEXT:    tzcntl %edi, %eax
; CHECK-NEXT:    decl %edi
; CHECK-NEXT:    andl $31, %eax
; CHECK-NEXT:    movl %edi, (%rsi)
; CHECK-NEXT:    retq
  %a = call {i32, i1} @llvm.usub.with.overflow.i32(i32 %x, i32 1)
  %b = extractvalue {i32, i1} %a, 0
  %c = extractvalue {i32, i1} %a, 1
  %d = call i32 @llvm.cttz.i32(i32 %x, i1 true)
  %e = select i1 %c, i32 0, i32 %d
  store i32 %b, i32* %y
  ret i32 %e
}
declare {i32, i1} @llvm.usub.with.overflow.i32(i32, i32)
