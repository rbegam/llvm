; Test to check uniformity of new VPInstructions introduced by predicator and their corresponding lowering
; to LLVM-IR generated by VPValue-based CG.

; RUN: opt -VPlanDriver -vplan-print-after-linearization -disable-vplan-subregions=0 -enable-vp-value-codegen -vplan-force-vf=2 %s < %s -S | FileCheck %s --check-prefixes=CHECK-PREDICATOR,CHECK

; CHECK-PREDICATOR-LABEL: After predication and linearization
; CHECK-PREDICATOR-NOT: {{Divergent.* and}}
; CHECK-PREDICATOR-NOT: {{Divergent.* or}}

; Checks for VPValue-based CG

; CHECK-LABEL:  define void @test_uniform_edge_to_uniform_block
; CHECK:        vector.body:
; CHECK-NEXT:    [[INDEX0:%.*]] = phi i32 [ 0, [[VECTOR_PH0:%.*]] ], [ [[INDEX_NEXT0:%.*]], [[VPLANNEDBB80:%.*]] ]
; CHECK-NEXT:    [[UNI_PHI0:%.*]] = phi i32 [ 0, [[VECTOR_PH0]] ], [ [[TMP15:%.*]], [[VPLANNEDBB80]] ]
; CHECK-NEXT:    [[VEC_PHI0:%.*]] = phi <2 x i32> [ <i32 0, i32 1>, [[VECTOR_PH0]] ], [ [[TMP14:%.*]], [[VPLANNEDBB80]] ]
; CHECK-NEXT:    [[SCALAR_GEP0:%.*]] = getelementptr i32, i32* [[A:%.*]], i32 [[UNI_PHI0]]
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast i32* [[SCALAR_GEP0]] to <2 x i32>*
; CHECK-NEXT:    [[WIDE_LOAD0:%.*]] = load <2 x i32>, <2 x i32>* [[TMP0]], align 4
; CHECK-NEXT:    [[TMP1:%.*]] = icmp eq <2 x i32> [[BROADCAST_SPLAT0:%.*]], <i32 42, i32 42>
; CHECK-NEXT:    [[EXTRACT0:%.*]] = extractelement <2 x i1> [[TMP1]], i32 0
; CHECK-NEXT:    [[TMP2:%.*]] = or i1 [[EXTRACT0]], true
; CHECK-NEXT:    [[BROADCAST_SPLATINSERT10:%.*]] = insertelement <2 x i1> undef, i1 [[TMP2]], i32 0
; CHECK-NEXT:    [[BROADCAST_SPLAT20:%.*]] = shufflevector <2 x i1> [[BROADCAST_SPLATINSERT10]], <2 x i1> undef, <2 x i32> zeroinitializer
; CHECK-NEXT:    [[TMP3:%.*]] = add <2 x i32> [[WIDE_LOAD0]], zeroinitializer
; CHECK-NEXT:    [[TMP4:%.*]] = xor <2 x i1> [[BROADCAST_SPLAT20]], <i1 true, i1 true>
; CHECK-NEXT:    br i1 [[TMP2]], label [[VPLANNEDBB0:%.*]], label [[VPLANNEDBB50:%.*]]

; CHECK:        VPlannedBB:
; CHECK-NEXT:    [[TMP5:%.*]] = or i1 [[EXTRACT0]], true
; CHECK-NEXT:    [[BROADCAST_SPLATINSERT30:%.*]] = insertelement <2 x i1> undef, i1 [[TMP5]], i32 0
; CHECK-NEXT:    [[BROADCAST_SPLAT40:%.*]] = shufflevector <2 x i1> [[BROADCAST_SPLATINSERT30]], <2 x i1> undef, <2 x i32> zeroinitializer
; CHECK-NEXT:    [[TMP6:%.*]] = add <2 x i32> [[WIDE_LOAD0]], <i32 1, i32 1>
; CHECK-NEXT:    [[TMP7:%.*]] = xor <2 x i1> [[BROADCAST_SPLAT40]], <i1 true, i1 true>
; FIXME: Both the "and" instructions below are marked as uniform by predicator, but vectorized by VPValue-CG.
; CHECK-NEXT:    [[TMP8:%.*]] = and <2 x i1> [[BROADCAST_SPLAT20]], [[TMP7]]
; CHECK-NEXT:    [[TMP9:%.*]] = and <2 x i1> [[BROADCAST_SPLAT20]], [[BROADCAST_SPLAT40]]
; CHECK-NEXT:    br i1 [[TMP5]], label [[VPLANNEDBB70:%.*]], label [[VPLANNEDBB50]]

; CHECK:        VPlannedBB5:
; CHECK-NEXT:    [[VEC_PHI60:%.*]] = phi <2 x i1> [ [[TMP8]], [[VPLANNEDBB0]] ], [ zeroinitializer, [[VECTOR_BODY0:%.*]] ]
; FIXME: The "or" instruction below is marked as uniform by predicator, but vectorized by VPValue-CG.
; CHECK-NEXT:    [[TMP10:%.*]] = or <2 x i1> [[VEC_PHI60]], [[TMP4]]
; CHECK-NEXT:    [[TMP11:%.*]] = add <2 x i32> [[WIDE_LOAD0]], <i32 2, i32 2>
; CHECK-NEXT:    br label [[VPLANNEDBB80]]
;

define void @test_uniform_edge_to_uniform_block(i32* %a, i32 %b) local_unnamed_addr {
entry:
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %for.body
;         BB0 (U)<--+
;       /     \     |
;     BB1 (U)  |    |
;    /   \    /     |
;   /     \ /       |
;  BB3   BB2        |
;   \    /          |
;    BB4            |
;     |             |
;    Latch----------+
for.body:
  %indvars.iv = phi i32 [ 0, %entry ], [ %indvars.iv.next, %latch ]
  %gep = getelementptr i32, i32 *%a, i32 %indvars.iv
  %ld = load i32, i32* %gep, align 4
  %uniform = icmp eq i32 %b,  42
  br label %bb0

bb0:
  %bb0.uniform = or i1 %uniform, true
  %bb0.add = add i32 %ld, 0
  br i1 %bb0.uniform, label %bb1, label %bb2

bb1:
  %bb1.uniform = or i1 %uniform, true
  %bb1.add = add i32 %ld, 1
  br i1 %bb1.uniform, label %bb3, label %bb2

bb2:
  %bb2.add = add i32 %ld, 2
  br label %bb4

bb3:
  %bb3.add = add i32 %ld, 3
  br label %bb4

bb4:
  %bb4.add = add i32 %ld, 4
  br label %latch

latch:
  %indvars.iv.next = add nuw nsw i32 %indvars.iv, 1
  %exitcond = icmp eq i32 %indvars.iv.next, 300
  br i1 %exitcond, label %for.end, label %for.body

for.end:
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"()]
  ret void
}

declare token @llvm.directive.region.entry()

declare void @llvm.directive.region.exit(token)
