//====-- Intel_FeatureInitCall.cpp ----------------====
//
//      Copyright (c) 2019 Intel Corporation.
//      All rights reserved.
//
//        INTEL CORPORATION PROPRIETARY INFORMATION
//
// This software is supplied under the terms of a license
// agreement or nondisclosure agreement with Intel Corp.
// and may not be copied or disclosed except in accordance
// with the terms of that agreement.
//
// This file defines the pass which insert libirc
// __intel_new_feature_proc_init[_n] to main function.
//

#include "X86.h"
#include "llvm/ADT/APInt.h"
#include "llvm/ADT/ArrayRef.h"
#include "llvm/ADT/SmallPtrSet.h"
#include "llvm/ADT/SmallVector.h"
#include "llvm/Analysis/TargetLibraryInfo.h"
#include "llvm/CodeGen/TargetLowering.h"
#include "llvm/CodeGen/TargetPassConfig.h"
#include "llvm/CodeGen/TargetSubtargetInfo.h"
#include "llvm/IR/Argument.h"
#include "llvm/IR/Attributes.h"
#include "llvm/IR/CallSite.h"
#include "llvm/IR/ConstantRange.h"
#include "llvm/IR/Constants.h"
#include "llvm/IR/DIBuilder.h"
#include "llvm/IR/DataLayout.h"
#include "llvm/IR/DerivedTypes.h"
#include "llvm/IR/Dominators.h"
#include "llvm/IR/Function.h"
#include "llvm/IR/IRBuilder.h"
#include "llvm/IR/InstIterator.h"
#include "llvm/IR/Instruction.h"
#include "llvm/IR/Instructions.h"
#include "llvm/IR/MDBuilder.h"
#include "llvm/IR/Module.h"
#include "llvm/IR/Type.h"
#include "llvm/IR/Value.h"
#include "llvm/Pass.h"
#include "llvm/Support/Casting.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/MathExtras.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/Target/TargetMachine.h"
#include "llvm/Transforms/Utils/BasicBlockUtils.h"
#include "llvm/Transforms/Utils/Cloning.h"
#include "llvm/Transforms/Utils/Local.h"

using namespace llvm;

#define DEBUG_TYPE "x86-feature-proc-init"

namespace {

//
// CPUs are built from a subset of features.
// Here, we define the enumeration of the features only.
//
#define CPU_FEATURE_BEGIN(feature) feature,
#define CPU_FEATURE_DOC(s)
#define CPU_FEATURE_ADD_FEATURE(f)
#define CPU_FEATURE_BIT_POS(n)
#define CPU_FEATURE_ADD_ISA_NAME(s)
#define CPU_FEATURE_LIBIRC_NAME(s)
#define CPU_FEATURE_ADD_MACRO_NAME(s)
#define CPU_FEATURE_AUTOGENERATED
#define CPU_FEATURE_END
// Start of the enumeration
typedef enum {
  c_feature_none = 0,
#include "intel_glob_isa_list.h"
  c_feature_libirc_end
} IntelLibFeatureId;
#undef CPU_FEATURE_BEGIN
#undef CPU_FEATURE_DOC
#undef CPU_FEATURE_ADD_FEATURE
#undef CPU_FEATURE_BIT_POS
#undef CPU_FEATURE_ADD_ISA_NAME
#undef CPU_FEATURE_LIBIRC_NAME
#undef CPU_FEATURE_ADD_MACRO_NAME
#undef CPU_FEATURE_AUTOGENERATED
#undef CPU_FEATURE_END

//
// The following features aren't used in libIRC (features that contribute cpu
// dispatching), so they are defined here.
// The whole features set is a superset of features defined here with those
// in libirc (glob_feature_list.h is actually a copy of that definition)
// for identifying a cpu.
// Note that these "features" are not necessarily identified via CPUID.
// For example, "c_feature_nwd" is not a CPUID feature, but was used by the
// compiler to switch on the newer Pentuim4 die.
//
typedef enum {
  // Based on PentiumIII CPU with SSE2 support.
  c_feature_nwd = c_feature_libirc_end,
  // Graphic processor.
  c_feature_gfx,
  c_features_num
} IntelFeatureId;

// These are all iterator MACROs associated with CPUs and FEATUREs
//
//
// Walk through all of the features.
//
#define FOR_EACH_FEATURE(feature)                                              \
  for ((feature) = (IntelFeatureId)(c_feature_none + 1);                       \
       (feature) < c_features_num;                                             \
       (feature) = (IntelFeatureId)((feature) + 1)) {
#define END_FOR_EACH_FEATURE }

// Walk through all ISAs.
#define FOR_EACH_LIBIRC_FEATURE(isa)                                           \
  for ((isa) = (IntelLibFeatureId)(c_feature_none + 1);                        \
       (isa) < c_feature_libirc_end; (isa) = (IntelLibFeatureId)((isa) + 1)) {
#define END_FOR_EACH_LIBIRC_FEATURE }

// Walk through all FEATUREs within a given set of FEATUREs.
//
#define FOR_EACH_FEATURE_IN_FEATURESET(set, feature)                           \
  FOR_EACH_FEATURE(feature) {                                                  \
    if ((set)[feature]) {
#define END_FOR_EACH_FEATURE_IN_FEATURESET                                     \
  }                                                                            \
  }                                                                            \
  END_FOR_EACH_FEATURE;

// Walk through all LIBIRC FEATUREs within a given set of FEATUREs.
//
#define FOR_EACH_LIBIRC_FEATURE_IN_FEATURESET(set, feature)                    \
  FOR_EACH_LIBIRC_FEATURE(feature) {                                           \
    if ((set)[feature]) {
#define END_FOR_EACH_LIBIRC_FEATURE_IN_FEATURESET                              \
  }                                                                            \
  }                                                                            \
  END_FOR_EACH_LIBIRC_FEATURE;

typedef uint64_t isa_vec_element_type;
typedef std::bitset<c_features_num> CpuInfoFeatureSet;
const int c_isa_vec_element_size = sizeof(isa_vec_element_type) * CHAR_BIT;
#define ISA_VEC_ARRAY_SIZE 2
// This structure holds information about LIBIRC feature within the driver
// context (icc).  BE maintains its own structure.
typedef struct {
  CpuInfoFeatureSet features;
  StringRef isa_names;
  std::vector<std::string> public_macro_names;
  // Currently libirc_name is used for verification purposes only.
  std::string libirc_name;
  int bitpos;
  // Those that can be autogenerated by the compiler have this flag set.
  bool autogenerated;
  bool visited;
} FeatureDefType;

FeatureDefType proc_info_features[c_feature_libirc_end];

class X86FeatureInitPass : public FunctionPass {
  TargetMachine *TM = nullptr;

public:
  static char ID; // Pass identification, replacement for typeid..

  X86FeatureInitPass() : FunctionPass(ID) {
    initializeX86FeatureInitPassPass(*PassRegistry::getPassRegistry());
  }

  void getAnalysisUsage(AnalysisUsage &AU) const override {
    AU.addRequired<TargetPassConfig>();
    AU.addRequired<TargetLibraryInfoWrapperPass>();
  }

  bool getTargetAttributes(Function &F,
                           std::vector<StringRef> &TargetFeatures) {
    StringRef TF = F.getFnAttribute("target-features").getValueAsString();

    if (TF.empty())
      return false;

    SmallVector<StringRef, 20> Features;
    TF.split(Features, ",");
    for (StringRef &Feature : Features) {
      if (Feature.startswith("+"))
        TargetFeatures.push_back(Feature.substr(1));
      else if (Feature.startswith("-")) {
        StringRef S = Feature.substr(1);
        auto Itr =
            std::find_if(std::begin(TargetFeatures), std::end(TargetFeatures),
                         [&](StringRef A) { return A == S; });
        TargetFeatures.erase(Itr);
      }
    }
    return true;
  }

  bool getCpuFeatureBitmap(isa_vec_element_type *masks,
                           std::vector<StringRef> &CpuFeatures) {

#define CPU_FEATURE_INFO_CLEAR(isa)                                            \
  proc_info_features[(isa)].features.reset();                                  \
  proc_info_features[(isa)].bitpos = -1;                                       \
  proc_info_features[(isa)].autogenerated = false;                             \
  proc_info_features[(isa)].visited = false;

// ISA table initialization.
#define CPU_FEATURE_BEGIN(isa)                                                 \
  {                                                                            \
    IntelLibFeatureId __curr_isa__ = (isa);                                    \
    proc_info_features[__curr_isa__].features[__curr_isa__] = 1;

#define CPU_FEATURE_DOC(s)
#define CPU_FEATURE_ADD_FEATURE(isa)                                           \
  if (!proc_info_features[(isa)].visited) {                                    \
    return false;                                                              \
  }                                                                            \
  proc_info_features[__curr_isa__].features[(isa)] = 1;                        \
  proc_info_features[__curr_isa__].features |=                                 \
      proc_info_features[(isa)].features;

#define CPU_FEATURE_BIT_POS(n) proc_info_features[__curr_isa__].bitpos = (n);
#define CPU_FEATURE_ADD_ISA_NAME(name)                                         \
  proc_info_features[__curr_isa__].isa_names = (name);

#define CPU_FEATURE_LIBIRC_NAME(name)                                          \
  proc_info_features[__curr_isa__].libirc_name = (name);
#define CPU_FEATURE_ADD_MACRO_NAME(name)                                       \
  proc_info_features[__curr_isa__].public_macro_names.push_back(               \
      std::string(name));
#define CPU_FEATURE_AUTOGENERATED                                              \
  proc_info_features[__curr_isa__].autogenerated = true;
#define CPU_FEATURE_END                                                        \
  proc_info_features[__curr_isa__].visited = true;                             \
  }

    for (int i = c_feature_generic_ia32; i < c_feature_libirc_end; i++) {
      CPU_FEATURE_INFO_CLEAR(i);
    }
#include "intel_glob_isa_list.h"

    for (auto CpuFeature : CpuFeatures) {
      IntelLibFeatureId feature_id;
      FOR_EACH_LIBIRC_FEATURE(feature_id) {
        if (proc_info_features[feature_id].isa_names == CpuFeature &&
            proc_info_features[feature_id].autogenerated) {
          int bitpos = proc_info_features[feature_id].bitpos;
          int idx = bitpos / c_isa_vec_element_size;
          masks[idx] |= 1ULL << (bitpos - idx * c_isa_vec_element_size);
        }
      }
      END_FOR_EACH_LIBIRC_FEATURE;
    }

    return true;
  }

  bool isMainFunction(Function &F) {
    return llvm::StringSwitch<bool>(F.getName())
      .Cases("main",
             "MAIN__", true)
      .Cases("wmain",
             "WinMain",
             "wWinMain",
             TM->getTargetTriple().isOSMSVCRT())
      .Default(false);  
  }

  bool runOnFunction(Function &F) override {
    TM = &getAnalysis<TargetPassConfig>().getTM<TargetMachine>();

    if (TM->Options.IntelAdvancedOptim == false)
      return false;
    if (isMainFunction(F) == false)
      return false;

    // Collect target feature mask
    std::vector<StringRef> TargetFeatures;
    if (getTargetAttributes(F, TargetFeatures) == false)
      report_fatal_error(
          "Advanced optimizations are enabled, but no target features");

    isa_vec_element_type CpuBitMap[ISA_VEC_ARRAY_SIZE] = {0, 0};
    getCpuFeatureBitmap(CpuBitMap, TargetFeatures);

    LLVM_DEBUG(dbgs() << "[Feature bitmap] : " << CpuBitMap << "\n");

    auto Entry = &F.getEntryBlock();
    IRBuilder<> IRB(Entry, Entry->getFirstInsertionPt());
    Value *Args[] = {
        ConstantInt::get(IRB.getInt32Ty(), 0),
        ConstantInt::get(IRB.getInt64Ty(), CpuBitMap[0]),
    };
    FunctionCallee FeatureInit = F.getParent()->getOrInsertFunction(
        "__intel_new_feature_proc_init", IRB.getVoidTy(), IRB.getInt32Ty(),
        IRB.getInt64Ty());
    IRB.CreateCall(FeatureInit, Args);

    for (int Index = 1; Index < ISA_VEC_ARRAY_SIZE; Index++) {
      if (CpuBitMap[Index]) {
        Value *ArgsN[] = {
            ConstantInt::get(IRB.getInt32Ty(), Index),
            ConstantInt::get(IRB.getInt64Ty(), CpuBitMap[Index]),
        };
        FunctionCallee FeatureInitN = F.getParent()->getOrInsertFunction(
            "__intel_new_feature_proc_init_n", IRB.getVoidTy(),
            IRB.getInt32Ty(), IRB.getInt64Ty());
        IRB.CreateCall(FeatureInitN, ArgsN);
      }
    }

    return true;
  }
};

} // end anonymous namespace

char X86FeatureInitPass::ID = 0;

INITIALIZE_PASS_BEGIN(X86FeatureInitPass, DEBUG_TYPE,
                      "X86 runtime feature initialization pass", false, false)
INITIALIZE_PASS_DEPENDENCY(TargetPassConfig)
INITIALIZE_PASS_END(X86FeatureInitPass, DEBUG_TYPE,
                    "X86 runtime feature initialization pass", false, false)

FunctionPass *llvm::createFeatureInitPass() { return new X86FeatureInitPass(); }
