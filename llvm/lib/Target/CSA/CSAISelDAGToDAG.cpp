//===-- CSAISelDAGToDAG.cpp - A dag to dag inst selector for CSA ----------===//
//
// Copyright (C) 2017-2018 Intel Corporation. All rights reserved.
//
// The information and source code contained herein is the exclusive
// property of Intel Corporation and may not be disclosed, examined
// or reproduced in whole or in part without explicit written authorization
// from the company.
//
//===----------------------------------------------------------------------===//
//
// This file defines an instruction selector for the CSA target.
//
//===----------------------------------------------------------------------===//

#include "CSA.h"
#include "CSATargetMachine.h"
#include "llvm/CodeGen/MachineFrameInfo.h"
#include "llvm/CodeGen/MachineFunction.h"
#include "llvm/CodeGen/MachineInstrBuilder.h"
#include "llvm/CodeGen/MachineRegisterInfo.h"
#include "llvm/CodeGen/SelectionDAG.h"
#include "llvm/CodeGen/SelectionDAGISel.h"
#include "llvm/IR/CallingConv.h"
#include "llvm/IR/Constants.h"
#include "llvm/IR/DerivedTypes.h"
#include "llvm/IR/Function.h"
#include "llvm/IR/Intrinsics.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/Target/TargetLowering.h"
using namespace llvm;

#define DEBUG_TYPE "csa-isel"

/// CSADAGToDAGISel - CSA specific code to select CSA machine
/// instructions for SelectionDAG operations.
///
namespace {
class CSADAGToDAGISel : public SelectionDAGISel {
  const CSATargetLowering &Lowering;
  const CSASubtarget &Subtarget;

public:
  CSADAGToDAGISel(CSATargetMachine &TM, CodeGenOpt::Level OptLevel)
      : SelectionDAGISel(TM, OptLevel),
        Lowering(*TM.getSubtargetImpl()->getTargetLowering()),
        Subtarget(*TM.getSubtargetImpl()) {}

  StringRef getPassName() const override {
    return "CSA DAG->DAG Pattern Instruction Selection";
  }

    // Include the pieces autogenerated from the target description.
#include "CSAGenDAGISel.inc"

private:
  // Complex patterns
  bool SelectRegImm(SDValue Opnd, SDValue &Result);

  bool SelectAddrRegIdx(SDNode *Parent, SDValue Addr, SDValue &Base,
                        SDValue &ScaledOffset);

  bool SelectAddrRegImm(SDNode *Parent, SDValue Addr, SDValue &Base,
                        SDValue &Offset);

  void Select(SDNode *N) override;
};
} // end anonymous namespace

/// createCSAISelDag - This pass converts a legalized DAG into a
/// CSA-specific DAG, ready for instruction scheduling.
///
FunctionPass *llvm::createCSAISelDag(CSATargetMachine &TM,
                                     CodeGenOpt::Level OptLevel) {
  return new CSADAGToDAGISel(TM, OptLevel);
}

// Match a register or immediate operand
bool CSADAGToDAGISel::SelectRegImm(SDValue Opnd, SDValue &Result) {
  if (ConstantSDNode *CN = dyn_cast<ConstantSDNode>(Opnd)) {
    SDLoc dl(Opnd);
    const ConstantInt &ci = *(CN->getConstantIntValue());
    Result = CurDAG->getTargetConstant(ci, dl, CN->getValueType(0));
    return true;
  }

  // Get the bits for FP types
  // See also CSAMCInstLower.cpp::Lower, case MO_FPImmediate
  if (ConstantFPSDNode *CN = dyn_cast<ConstantFPSDNode>(Opnd)) {
    SDLoc dl(Opnd);
    const ConstantFP *f = CN->getConstantFPValue();
    APFloat apf         = f->getValueAPF();
    bool ignored;
    if (f->getType() == Type::getFloatTy(f->getContext()))
      apf.convert(APFloat::IEEEdouble(), APFloat::rmNearestTiesToEven,
                  &ignored);
    double d = apf.convertToDouble();
    if (f->getType()->getTypeID() == Type::FloatTyID) {
      // Result = CurDAG->getTargetConstantFP(f, dl, EVT(MVT::f32)); ?
      union {
        int i;
        float f;
      } ifu;
      ifu.f  = d;
      Result = CurDAG->getTargetConstant(ifu.i, dl, MVT::i64);
      return true;
    } else if (f->getType()->getTypeID() == Type::DoubleTyID) {
      // Result = CurDAG->getTargetConstantFP(f, dl, EVT(MVT::f64)); ?
      union {
        long long l;
        double d;
      } ldu;
      ldu.d  = d;
      Result = CurDAG->getTargetConstant(ldu.l, dl, MVT::i64);
      return true;
    }
  }

  // Fall back to register match
  Result = Opnd;
  return true;
}

// Scaled indexing (for scaling by 2/4/8 matching opcode access size)
bool CSADAGToDAGISel::SelectAddrRegIdx(SDNode *Parent, SDValue Addr,
                                       SDValue &Base, SDValue &ScaledOffset) {
  MemSDNode *memSDNode = dyn_cast<MemSDNode>(Parent);
  // If add operation, we can optimize.
  if (memSDNode && Addr.getOpcode() == ISD::ADD) {
    // true if node is a constant.
    if (dyn_cast<ConstantSDNode>(Addr.getOperand(1))) {
      return false;
    }

    // The shift amount value needs to match the size of the operation
    unsigned int byteSize = memSDNode->getMemoryVT().getStoreSize();
    // Better be over a SHL
    if (Addr.getOperand(1).getOpcode() != ISD::SHL)
      return false;
    // And the shift amount must match the size of the reference
    ConstantSDNode *shamt =
      dyn_cast<ConstantSDNode>(Addr.getOperand(1).getOperand(1));
    if (!shamt)
      return false;
    if ((1u << shamt->getZExtValue()) != byteSize)
      return false;

    // set address and offset.
    Base         = Addr.getOperand(0);
    ScaledOffset = Addr.getOperand(1).getOperand(0);
    return true;
  }
  return false;
}

// Displacement
bool CSADAGToDAGISel::SelectAddrRegImm(SDNode *Parent, SDValue Addr,
                                       SDValue &Base, SDValue &Offset) {
  if (CurDAG->isBaseWithConstantOffset(Addr)) {
    // If operation is a stack operation base becomes offset of
    // the frame.
    if (auto FIN = dyn_cast<FrameIndexSDNode>(Addr.getOperand(0))) {
      Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), MVT::i64);
    }
    // otherwise, this isn't a stack operation so use passed in
    // register offset.
    else {
      Base = Addr.getOperand(0);
    }
    SDLoc dl(Parent);
    ConstantSDNode *CN = dyn_cast<ConstantSDNode>(Addr.getOperand(1));
    Offset = CurDAG->getTargetConstant(CN->getSExtValue(), dl, MVT::i64);
    return true;
  }

  if (Addr.getOpcode() == ISD::ADD) {
    Base   = Addr.getOperand(0);
    Offset = Addr.getOperand(1);
    return true;
  }
  return false;
}

void CSADAGToDAGISel::Select(SDNode *Node) {
  SDLoc dl(Node);

  // Dump information about the Node being selected
  DEBUG(errs() << "Selecting: ");
  DEBUG(Node->dump(CurDAG));
  DEBUG(errs() << "\n");

  // If we have a custom node, we already have selected!
  if (Node->isMachineOpcode()) {
    DEBUG(errs() << "== "; Node->dump(CurDAG); errs() << "\n");
    Node->setNodeId(-1);
    return;
  }

  // Custom selection
  switch (Node->getOpcode()) {
  default:
    break;
  case ISD::FrameIndex: {
    int FI = cast<FrameIndexSDNode>(Node)->getIndex();
    SDValue TFI =
      CurDAG->getTargetFrameIndex(FI, TLI->getPointerTy(MF->getDataLayout()));
    CurDAG->SelectNodeTo(Node, CSA::MOV64, MVT::i64, TFI);
    return;
  }
  }

  // Select the default instruction
  SelectCode(Node);

  DEBUG(errs() << "=> ");
  DEBUG(Node->dump(CurDAG));
  DEBUG(errs() << "\n");

  return;
}
