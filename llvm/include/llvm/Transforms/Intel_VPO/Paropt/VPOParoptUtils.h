//=-- VPOParoptUtils.h - Class definition for VPO Paropt utilites -*- C++ -*-=//
//
// Copyright (C) 2015-2016 Intel Corporation. All rights reserved.
//
// The information and source code contained herein is the exclusive property
// of Intel Corporation and may not be disclosed, examined or reproduced in
// whole or in part without explicit written authorization from the company.
//
// Authors:
// --------
// Xinmin Tian (xinmin.tian@intel.com)
//
// Major Revisions:
// ----------------
// Nov 2015: Initial Implementation of OpenMP runtime APIs (Xinmin Tian)
//
//===----------------------------------------------------------------------===//
///
/// \file
/// This file defines the VPOParoptUtils class and provides a set of utilities
/// that are used for Paropt transformation and multi-threaded code generation.
///
//===----------------------------------------------------------------------===//

#ifndef LLVM_TRANSFORM_VPO_PAROPT_UTILS_H
#define LLVM_TRANSFORM_VPO_PAROPT_UTILS_H

#include "llvm/ADT/SmallVector.h"
#include "llvm/ADT/StringMap.h"
#include "llvm/Analysis/LoopInfo.h"
#include "llvm/IR/DebugInfo.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/Support/Debug.h"
#include "llvm/Transforms/Utils/ValueMapper.h"
#include "llvm/Transforms/Utils/Cloning.h"
#include "llvm/Analysis/Intel_VPO/WRegionInfo/WRegionUtils.h"
#include <unordered_map>

// Use trampoline for internal microtasks
#define KMP_IDENT_IMB              0x01

// Use c-style ident structure
#define KMP_IDENT_KMPC             0x02

// Entry point generated using Cluster OpenMP switch
#define KMP_IDENT_CLOMP            0x04

// Entry point generated by auto-parallelization
#define KMP_IDENT_AUTOPAR          0x08

// compiler generates atomic reduction option for kmpc_reduce
#define KMP_IDENT_ATOMIC_REDUCE    0x10

// replaced by KMP_IDENT_BARRIER_EXPL below
// #define KMP_IDENT_EXPLICIT_BARRIER 0x20

//
// Implicit barriers are classified further
//
// = 0000 0010 0000 barrier directive in user's code
#define KMP_IDENT_BARRIER_EXPL           0x0020

// = 0000 0100 0000
#define KMP_IDENT_BARRIER_IMPL           0x0040

// = 0001 1100 0000 unused by cmplr
#define KMP_IDENT_BARRIER_IMPL_MASK      0x01C0

// = 0000 0100 0000
#define KMP_IDENT_BARRIER_IMPL_FOR       0x0040

// = 0000 1100 0000
#define KMP_IDENT_BARRIER_IMPL_SECTIONS  0x00C0

// = 0001 0100 0000
#define KMP_IDENT_BARRIER_IMPL_SINGLE    0x0140

// = 0001 1100 0000 workshare construct not supported by cmplr
#define KMP_IDENT_BARRIER_IMPL_WORKSHARE 0x01C0

namespace llvm {

class Value;
class Module;
class Function;
class Type;
class BasicBlock;
class Loop;
class LoopInfo;
class DominatorTree;
class StringRef;
class CallInst;
class IntrinsicInst;
class Constant;
class LLVMContext;

namespace vpo {

/// \brief This class contains a set of utility functions used by VPO Paropt 
/// Transformation passes.
class VPOParoptUtils {

public:

    /// \brief Generate OpenMP runtime __kmpc_begin(&loc, flags) 
    /// initialization code. The generated runtime routine call is invoked 
    /// (only once) right after entering the main function.
    static CallInst* genKmpcBeginCall(Function *F, Instruction *InsertPt, 
                                      StructType *IdentTy);

    /// \brief Generate OpenMP runtime __kmpc_end(&loc) termination code 
    /// The generated runtime routine call is invoked (only once) right 
    /// before exiting the main function.
    static CallInst* genKmpcEndCall(Function *F, 
                                    Instruction *InsertPt, 
                                    StructType *IdentTy);
   
    /// \brief Generate OpenMP runtime __kmpc_global_thread_num() call 
    /// The generated runtime routine call is invoked (only once) to get 
    /// runtime right 
    /// after entering each function that contains OpenMP constructs 
    static CallInst* genKmpcGlobalThreadNumCall(Function    *F, 
                                                Instruction *InsertPt, 
                                                StructType  *IdentTy);
      
    /// \brief Generate OpenMP runtime ForkTest = ___kmpc_ok_to_fork(&loc) 
    static CallInst* genKmpcForkTest(WRegionNode *W, StructType *IdentTy, 
                                     Instruction *InsertPt);

    /// \brief Generate source location information from Instruction DebugLoc
    static AllocaInst* genKmpcLocfromDebugLoc(Function *F, Instruction *AI, 
                                              StructType *IdentTy, int Flags, 
                                              BasicBlock *BS, BasicBlock *BE);

    /// \brief Generate a call to notify the runtime system that the static 
    /// loop scheduling is started 
    /// call void @__kmpc_for_static_init_4(%ident_t* %loc, i32 %tid,
    ///             i32 schedtype, i32* %islast,i32* %lb, i32* %ub, i32* %st,
    ///             i32 inc, i32 chunk)
    static CallInst* genKmpcStaticInit(WRegionNode *W,
                                       StructType *IdentTy,
                                       Value *Tid, Value *SchedType, 
                                       Value *IsLastVal, Value *LB, Value *UB, 
                                       Value *ST, Value *Inc, Value *Chunk,
                                       Instruction *InsertPt);

    /// \brief Generate a call to notify the runtime system that the static 
    /// loop scheduling is done 
    ///   call void @__kmpc_for_static_fini(%ident_t* %loc, i32 %tid)
    static CallInst* genKmpcStaticFini(WRegionNode *W,
                                       StructType *IdentTy,
                                       Value *Tid, Instruction *InsertPt);

    /// \brief Generate source location information for Explicit barrier
    static AllocaInst* genKmpcLocforExplicitBarrier(Function *F, 
                                                    Instruction *InsertPt, 
                                                    StructType *IdentTy, 
                                                    BasicBlock *BB);

    /// \brief Generate source location information for Implicit barrier
    static AllocaInst* genKmpcLocforImplicitBarrier(WRegionNode *W,
                                                    Function *F,
                                                    Instruction *InsertPt,
                                                    StructType *IdentTy,
                                                    BasicBlock *BB);

    /// \brief Generates KMPC runtime call to the function \p IntrinsicName
    /// with arguments Loc(obtained using \p IdentTy), Tid (Obtained using \p
    /// TidPtr), and \p Args. The function inserts Instructions into the IR for
    /// obtaining Loc and Tid, before the \p InsertPt, and inserts the function
    /// prototype into the module symbol table. But it does not insert the final
    /// KMPC call.
    /// \returns The generated CallInst.
    static CallInst *genKmpcCallWithTid(WRegionNode *W, StructType *IdentTy,
                                        AllocaInst *TidPtr,
                                        Instruction *InsertPt,
                                        StringRef IntrinsicName, Type *ReturnTy,
                                        ArrayRef<Value *> Args);

  private:
    ///  \name Private constructor and destructor to disable instantiation.
    /// @{

    VPOParoptUtils() = delete;
    ~VPOParoptUtils() = delete;

    /// @}

    /// \brief Generates KMPC runtime call to the function \p IntrinsicName
    /// with arguments Loc(obtained using \p IdentTy) and \p Args. The function
    /// inserts Instructions into the IR for obtaining Loc, before the \p
    /// InsertPt, and inserts the function prototype into the module symbol
    /// table. But it does not insert the final KMPC call.
    /// \param IdentTy and \p InsertPt are used to obtain Loc needed by the
    /// KMPC call.
    /// \param IntrinsicName is the name of the function.
    /// \param ReturnTy is the return type of the function.
    /// \param Args arguments for the function call.
    /// \returns the generated CallInst.
    static CallInst *genKmpcCall(WRegionNode *W, StructType *IdentTy,
                                 Instruction *InsertPt, StringRef IntrinsicName,
                                 Type *ReturnTy, ArrayRef<Value *> Args);

    /// \brief Generates a call to the function \p FnName.
    /// If the function is not already declared in the module \p M, then it is
    /// declared here. Otherwise, the existing declaration is used.
    /// \param M Module for which the call is generated.
    /// \param FnName Name of the function.
    /// \param ReturnTy Return type of the function. 
    /// \param FnArgs Arguments for the function call.
    static CallInst *genCall(Module *M, StringRef FnName, Type *ReturnTy,
                             ArrayRef<Value *> FnArgs);
    };

} // End vpo namespace
} // End llvm namespace

#endif // LLVM_TRANSFORMS_VPO_PAROPT_UTILS_H

