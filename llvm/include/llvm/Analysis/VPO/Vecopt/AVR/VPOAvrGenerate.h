//===------------------------------------------------------------*- C++ -*-===//
//
//   Copyright (C) 2015 Intel Corporation. All rights reserved.
//
//   The information and source code contained herein is the exclusive
//   property of Intel Corporation. and may not be disclosed, examined
//   or reproduced in whole or in part without explicit written authorization
//   from the company.
//
//   Source file:
//   ------------
//   VPOAvrGenerate.h -- Defines the analysis pass used to generate AVR nodes
//   from LLVM IR and HIR.
//
//===----------------------------------------------------------------------===//

#ifndef LLVM_ANALYSIS_VPO_AVR_GENERATE_H
#define LLVM_ANALYSIS_VPO_AVR_GENERATE_H

#include "llvm/Pass.h"
#include "llvm/Analysis/VPO/Vecopt/AVR/VPOAvr.h"
#include "llvm/Analysis/VPO/Vecopt/AVR/VPOAvrUtils.h"
#include "llvm/Analysis/VPO/Vecopt/AVR/VPOAvrUtilsIR.h"

namespace llvm { // LLVM Namespace

class DominatorTree;
class LoopInfo;

namespace vpo {  // VPO Vectorizer namespace

class IdentifyVectorCandidates;

class AVRGenerate : public FunctionPass {

private:

  /// The current function being analyzed.
  Function *Func;

  /// The AVRFunction node generated for this function.
  /// (Currently Stress Testing Only)
  AVRFunction *AvrFunction;

  /// The AVR top level container which holds all AVR generated by Avr
  /// construction.
  AVRContainerTy AVRList;

  /// The top-level AVR WRN currently being processed/generated.
  AVRWrn *AvrWrn;

  /// True when in AVR scalar stress testing mode
  bool ScalarStressTest;

  /// Identify Vector Candidates Pass
  IdentifyVectorCandidates *VC;  

  /// Dominator Tree
  DominatorTree *DT;

  /// Loop Info for this function.
  const LoopInfo *LI;

  /// \brief Sets AvrFunction node for this pass.
  void setAvrFunction(AVRFunction *AFunc) { AvrFunction = AFunc; }

  /// \brief Sets the top-level AvrWrn Node for this pass. 
  void setAvrWrn(AVRWrn *AWrn) { AvrWrn = AWrn; }

  /// \brief Sets the LLVM Function currently being analysed.
  void setLLVMFunction(Function *F) { Func = F; }

  /// \brief Sets the Loop Info for this function.
  void setLoopInfo(const LoopInfo *LpIn) { LI = LpIn; }

  /// \brief Set stress testing mode.
  void setStressTest(bool ST) { ScalarStressTest = ST; }

  /// \brief Optimize the abstract layer with Loops
  void formAvrLoops();

  /// \brief For given AvrNode, search children for loops and insert
  /// AVRLoops where found.
  void formAvrLoopNest(AVR *AvrNode);

  /// \brief For given AVRFunction node, search children for loops and insert
  /// AVRLoops where found.
  void formAvrLoopNest(AVRFunction *AvrFunction);

  /// \brief For given AvrWrn node, search children for loops and insert
  /// AVRLoops where found.
  void formAvrLoopNest(AVRWrn *AvrWrn);

  /// \bried Optimize the abstract layer with Ifs/splits
  void formAvrSplits();

  /// \brief Removes AVRWrn nodes from the constructed abstract layer list.
  void cleanupAvrWrnNodes();

public:

  AVRGenerate();

  // Pass Identification
  static char ID;

  bool runOnFunction(Function &F);
  void create();
  void getAnalysisUsage(AnalysisUsage &AU) const override;
  void print(raw_ostream &OS, const Module * = nullptr) const override;
  void print(raw_ostream &OS, unsigned Depth = 1, 
             unsigned VerbosityLevel = 1) const;
  void dump(unsigned Level = 1) const;

  /// \brief Builds the Abstract Layer used in vectorization. AVR nodes
  /// are constructed.
  void buildAbstractLayer();

  /// \brief Builds an AVR List for incoming this LLVM IR Function. Creates
  /// an AVRFunction and then builds AVR for body. (Used for stress
  /// testing of AVR construction)
  void buildAvrsForFunction();

  /// \brief Builds AVRs for the instructions of this LLVM function.
  void buildBody();

  /// \brief Builds an AVR List for loop candidates identified as
  /// vectorization candidates via IdenitfyCandidates analysis pass
  /// and WRNInfo analysis.
  void buildAvrsForVectorCandidates();

  /// \brief Recursive preorder traversal walk of Basic Block, which
  /// builds and AVR at InsertionPos. 
  AVR *preorderTravAvrBuild(BasicBlock *BB, AVR *InsertionPos);

  /// \brief This function generates a sequnece of AVR nodes for
  /// each instruction in the given LLVM IR basic block and inserts
  /// them into an AVR List at Insertpos
  AVR *generateAvrInstSeqForBB(BasicBlock *BB, AVR *InsertionPos);

  /// \brief Returns true is AvrGenerate Analysis pass list is empty
  bool isAvrGenerateListEmpty() { return AVRList.empty(); }

  /// \brief Returns the AvrFunction node for this pass.
  AVRFunction *getAvrFunction() { return AvrFunction; }

  /// \brief Returns the top-level AvrWrn node for this pass.
  //  TODO: In future WRNs be build a graph. Need to handle appropriately.
  AVRWrn *getAvrWrn() { return AvrWrn; }

  /// \brief Returns the LLVM Function currently being analyzed.
  Function *getLLVMFunction() { return Func; }

  /// \brief Returns the Loop Info for this function.
  const LoopInfo *getLoopInfo() { return LI; }

  /// \brief Code generation for AVRs. We have this under analysis for
  /// now. Clients call this from a transform pass. This will change
  /// and will move into transforms once we have AVR visitors. Returns 
  /// true if code was genreated from AVR.
  bool codeGen();

  // Iterators to iterate over generated AVRList
  typedef AVRContainerTy::iterator iterator;
  typedef AVRContainerTy::const_iterator const_iterator;
  typedef AVRContainerTy::reverse_iterator reverse_iterator;
  typedef AVRContainerTy::const_reverse_iterator const_reverse_iterator;

  // Iterator Methods
  iterator begin() { return AVRList.begin(); }
  const_iterator begin() const { return AVRList.begin(); }
  iterator end() { return AVRList.end(); }
  const_iterator end() const { return AVRList.end(); }

  reverse_iterator rbegin() { return AVRList.rbegin(); }
  const_reverse_iterator rbegin() const { return AVRList.rbegin(); }
  reverse_iterator rend() { return AVRList.rend(); }
  const_reverse_iterator rend() const { return AVRList.rend(); }

  /// /brief Release the memory of AVRList container built by this pass.
  void releaseMemory();

};

} // End VPO Vectorizer Namespace
} // End LLVM Namespace

#endif // LLVM_ANALYSIS_VPO_AVR_GENERATE_H
