//===------------------------------------------------------------*- C++ -*-===//
//
//   Copyright (C) 2015-2016 Intel Corporation. All rights reserved.
//
//   The information and source code contained herein is the exclusive
//   property of Intel Corporation. and may not be disclosed, examined
//   or reproduced in whole or in part without explicit written authorization
//   from the company.
//
//   Source file:
//   ------------
//   VPOAvrGenerate.h -- Defines the analysis pass used to generate AVR nodes
//   from LLVM IR and HIR.
//
//===----------------------------------------------------------------------===//

#ifndef LLVM_ANALYSIS_VPO_AVR_GENERATE_H
#define LLVM_ANALYSIS_VPO_AVR_GENERATE_H

#include "llvm/Pass.h"
#include "llvm/IR/Dominators.h"

#include "llvm/Analysis/VPO/Vecopt/AVR/VPOAvr.h"
#include "llvm/Analysis/VPO/Vecopt/AVR/VPOAvrUtils.h"
#include "llvm/Analysis/VPO/Vecopt/AVR/VPOAvrUtilsIR.h"
#include "llvm/Analysis/VPO/Vecopt/AVR/VPOAvrUtilsHIR.h"

#include "llvm/IR/Intel_LoopIR/HLSwitch.h"
#include "llvm/IR/Intel_LoopIR/HLLoop.h"
#include "llvm/IR/Intel_LoopIR/HLRegion.h"
#include "llvm/IR/Intel_LoopIR/HLIf.h"
#include "llvm/IR/Intel_LoopIR/HLInst.h"
#include "llvm/IR/Intel_LoopIR/RegDDRef.h"
#include "llvm/IR/Intel_LoopIR/HIRVisitor.h"

#include "llvm/Analysis/Intel_LoopAnalysis/HIRParser.h"
#include "llvm/Analysis/Intel_LoopAnalysis/DDAnalysis.h"
#include "llvm/Analysis/Intel_LoopAnalysis/HIRLocalityAnalysis.h"

#include "llvm/Transforms/Intel_LoopTransforms/Utils/HLNodeUtils.h"

using namespace llvm::loopopt;

namespace llvm { // LLVM Namespace

class LoopInfo;
class DominatorTree;
struct PostDominatorTree;

namespace vpo {  // VPO Vectorizer namespace

// Enumeration for Abstract Layer optimizations
enum ALOpts { ALBuild, ALLoopOpt, ALBranchOpt, ALExprTreeOpt};
enum NodeChange { Removal, Insertion, Modification};

// Forward Declarations
class ALChange;
class IdentifyVectorCandidates;
class CandidateIf;

class AVRGenerateBase : public FunctionPass {
protected:
  /// The current function being analyzed.
  Function *Func;

  /// The AVRFunction node generated for this function.
  /// (Currently Stress Testing Only)
  AVRFunction *AvrFunction;

  /// The top level container which holds all AVRs generated by Avr
  /// construction which is known as the Abstract Layer.
  AVRContainerTy AbstractLayer;

  /// The top-level AVR WRN currently being processed/generated.
  AVRWrn *AvrWrn;

  /// DisableALBuild - True if AL is not to be built.
  bool DisableALBuild;

  /// DisableLoopOpt - True if AvrIf optimization is disabled.
  bool DisableLoopOpt;

  /// DisableAvrBranchOpt - True if AvrBranch optimization is disabled.
  bool DisableAvrBranchOpt;

  /// DisableAvrExprTreeOpt - True if AvrExprTree optimization is disabled.
  bool DisableAvrExprTreeOpt;

  /// ALChangeLog - Vector containing all changes, additions, removals,
  /// modifications of AL from optimizations.
  SmallVector<const ALChange *, 32> ALChangeLog;

  /// \brief Sets AvrFunction node for this pass.
  void setAvrFunction(AVRFunction *AFunc) { AvrFunction = AFunc; }

  /// \brief Sets the top-level AvrWrn Node for this pass. 
  void setAvrWrn(AVRWrn *AWrn) { AvrWrn = AWrn; }

  /// \brief Sets the LLVM Function currently being analysed.
  void setLLVMFunction(Function *F) { Func = F; }

  // Functions for AVR Loop formation.
  //
  // Some functions are generic implementation and thus defined within
  // this class. Others require input IR specific implementations and
  // thus defined as virtual function.

  /// \brief Optimize the abstract layer with AVRLoops.
  void optimizeLoopControl();

  /// \brief For given AvrNode, search children for loops and insert
  /// AVRLoops where found.
  void formAvrLoopNest(AVR *AvrNode);

  /// \brief For given AVRFunction node, search children for loops and insert
  /// AVRLoops where found.
  virtual void formAvrLoopNest(AVRFunction *AvrFunction) { };

  /// \brief For given AvrWrn node, search children for loops and insert
  /// AVRLoops where found.
  virtual void formAvrLoopNest(AVRWrn *AvrWrn) { };

  // Functions for AVR If hiearchy recognition.
  //
  // Implementation is almost generic. Keep it here for now.

  /// \brief Optimize the abstract layer with Ifs/splits
  void optimizeAvrBranches();

  /// \brief Cleans up unsed AVRs after AvrBranch optimization.
  void cleanupBranchOpt(CandidateIf *CandIf);

public:
  AVRGenerateBase(char &ID);

  /// AvrLabels - Map of avr labels and basic blocks generated in AL.
  SmallDenseMap<BasicBlock *, AVRLabelIR *, 64> AvrLabels;

  bool runOnFunction(Function &F);
  void create();
  void getAnalysisUsage(AnalysisUsage &AU) const override;
  void print(raw_ostream &OS, const Module * = nullptr) const override;
  void print(raw_ostream &OS, unsigned Depth = 1, 
             VerbosityLevel VLevel = PrintBase) const;
  void dump(VerbosityLevel VLevel = PrintBase) const;

  /// \brief Builds the Abstract Layer used in vectorization. AVR nodes
  /// are constructed.
  virtual void buildAbstractLayer() = 0;

  /// \brief Returns true is AvrGenerate Analysis pass list is empty
  bool isAbstractLayerEmpty() { return AbstractLayer.empty(); }

  /// \brief Returns the AvrFunction node for this pass.
  AVRFunction *getAvrFunction() { return AvrFunction; }

  /// \brief Returns the top-level AvrWrn node for this pass.
  //  TODO: In future WRNs be build a graph. Need to handle appropriately.
  AVRWrn *getAvrWrn() { return AvrWrn; }

  /// \brief Returns the LLVM Function currently being analyzed.
  Function *getLLVMFunction() { return Func; }

  /// \brief Code generation for AVRs. We have this under analysis for
  /// now. Clients call this from a transform pass. This will change
  /// and will move into transforms once we have AVR visitors. Returns 
  /// true if code was generated from AVR.
  bool codeGen();

  // Iterators to iterate over generated AbstractLayer
  typedef AVRContainerTy::iterator iterator;
  typedef AVRContainerTy::const_iterator const_iterator;
  typedef AVRContainerTy::reverse_iterator reverse_iterator;
  typedef AVRContainerTy::const_reverse_iterator const_reverse_iterator;

  // Iterator Methods
  iterator begin() { return AbstractLayer.begin(); }
  const_iterator begin() const { return AbstractLayer.begin(); }
  iterator end() { return AbstractLayer.end(); }
  const_iterator end() const { return AbstractLayer.end(); }

  reverse_iterator rbegin() { return AbstractLayer.rbegin(); }
  const_reverse_iterator rbegin() const { return AbstractLayer.rbegin(); }
  reverse_iterator rend() { return AbstractLayer.rend(); }
  const_reverse_iterator rend() const { return AbstractLayer.rend(); }

  /// /brief Release the memory of AVRList container built by this pass.
  void releaseMemory();
};

class AVRGenerateHIR : public AVRGenerateBase {
private:
  /// HIRP - HIR Parser
  HIRParser *HIRP;

  class AVRGenerateVisitor : public HIRVisitor<AVRGenerateVisitor, AVR *> {
  public:
    AVR *visitRegion(HLRegion *R);
    AVR *visitLoop(HLLoop *L);
    AVR *visitIf(HLIf *I);

    AVR *visitSwitch(HLSwitch *S);

    AVR *visitInst(HLInst *I);

    AVR *visitGoto(HLGoto *G);
    AVR *visitLabel(HLLabel *L);
  };

public:
  static char ID;

  AVRGenerateHIR();
  bool runOnFunction(Function &F);
  void getAnalysisUsage(AnalysisUsage &AU) const override;

  void buildAbstractLayer();
};

class AVRGenerate : public AVRGenerateBase {

private:

  /// True when in AVR scalar stress testing mode
  bool ScalarStressTest;

  /// VC - Identify Vector Candidates Pass
  IdentifyVectorCandidates *VC;  

  /// DT - Dominator Tree
  DominatorTree *DT;

  /// PDT - Post Dominator Tree
  PostDominatorTree *PDT;

  /// LI - Loop Info for this function.
  const LoopInfo *LI;

  /// \brief Sets the Loop Info for this function.
  void setLoopInfo(const LoopInfo *LpIn) { LI = LpIn; }

  /// \brief Set stress testing mode.
  void setStressTest(bool ST) { ScalarStressTest = ST; }

  //
  // Functions for AVR construction.
  //

  void buildAbstractLayer();

  /// \brief Builds an AVR List for incoming this LLVM IR Function. Creates
  /// an AVRFunction and then builds AVR for body. (Used for stress
  /// testing of AVR construction)
  void buildAvrsForFunction();

  /// \brief Builds an AVR List for loop candidates identified as
  /// vectorization candidates via IdenitfyCandidates analysis pass
  /// and WRNInfo analysis.
  void buildAvrsForVectorCandidates();

  /// \brief Recursive preorder traversal walk of Basic Block, which
  /// builds and AVR at InsertionPos. 
  AvrItr preorderTravAvrBuild(BasicBlock *BB,  AvrItr InsertionPos);

  /// \brief This function generates a sequnece of AVR nodes for
  /// each instruction in the given LLVM IR basic block and inserts
  /// them into an AVR List at Insertpos
  AvrItr generateAvrInstSeqForBB(BasicBlock *BB, AvrItr InsertionPos);

  /// \brief Generates terminator AVR for given BB
  AVR *generateAvrTerminator(BasicBlock *BB, AVR *InsertionPos,
                             AVR *ACondition);

  /// \brief Returns AVR that sets boolean bit for conditional branch.
  AVR *findAvrConditionForBI(BasicBlock *BB, BranchInst *BI, AVR *InsertionPos);

  //
  // Functions for AVR Loop formation.
  //

  void formAvrLoopNest(AVRFunction *AvrFunction);
  void formAvrLoopNest(AVRWrn *AvrWrn);

  /// \brief Given AvrLabel of loop latch, find the conditional branch
  /// and mark as bottom test.
  void markLoopBottomTest(AVRLabel *LoopLatchLabel);

  /// \brief Removes AVRWrn nodes from the constructed abstract layer list.
  void cleanupAvrWrnNodes();

public:

  AVRGenerate();

  // Pass Identification
  static char ID;

  bool runOnFunction(Function &F);
  void getAnalysisUsage(AnalysisUsage &AU) const override;

  /// \brief Returns the Loop Info for this function.
  const LoopInfo *getLoopInfo() { return LI; }

};

// Abstract Layer objects

// Experimental Feature
/// \brief This class defines an entry into the Abstract Layer change log. Each
/// modification made to the Abstract Layer after the initial AL is built,
/// generates an ALChange object. The collection of these objects track changes
/// made to the AL through AVR optimzations. We save these records in the
/// ALChangeLog.  The intention of the ALChangeLog is to be used for performance
/// tuning in the vectorizer cost model.

// TODO: Current implementation only sets up framework for tracking changes.
// Need to add changes for tracking UniqieID in AL graph. 
class ALChange {

private:

  /// Avr - The AVR node which has been changed.
  AVR *Avr;

  /// ALOptimization - The AL optimization which modified Avr.
  ALOpts ALOptimization;

  /// ChangeType - The type of change the Avr has undergone.
  NodeChange ChangeType;

public:

  ALChange(AVR* A, ALOpts ALOpt, NodeChange ChangeT) :
    Avr(A), ALOptimization(ALOpt), ChangeType(ChangeT) {}
  ~ALChange();

};

/// \brief A simple class which represents a block of AVRs. Currently used to
/// populate "true" and "false" blocks of AVRIf nodes.
///
/// These intended usage of this class is:
/// (1) The AvrBlock you wish to descibe only contains AVRs which have the same
///     immediate parent.
/// (2) BlockBegin occurs lexically before BlockEnd in the AL.
///
class AvrBlock {
private:

  /// BlockBegin - Pointer to the first AVR of your block. 
  AVR *BlockBegin;

  /// BlockEnd - Pointer to the last AVR of your block.
  AVR *BlockEnd;

public:

  AvrBlock(AVR *BBegin = nullptr, AVR *BEnd = nullptr) :
    BlockBegin(BBegin), BlockEnd(BEnd) {}
  ~AvrBlock();

  /// \brief Sets the first avr of the AvrBlock.
  void setBegin(AVR *Begin) { BlockBegin = Begin; }

  /// \brief Sets the last avr of the AvrBlock.
  void setEnd(AVR *End) { BlockEnd = End; }

  /// \brief Returns the first avr of the AvrBlock.
  AVR *getBegin() { return BlockBegin; }

  /// \brief Returns the last avr of the Avr Block.
  AVR *getEnd() { return BlockEnd; }
};

/// \brief CandidateIf objects are created during AVRBranch optimization. During
/// this analysis, a conditional AVRBranch is evaluated if it can be replaced by
/// an AVRIf. This object is created and populated with all information needed
/// downstream to transform the conditional AVRBranch to an AVRIf node.
class CandidateIf {

private:

  /// ABranch - The conditional AvrBranch to be transformed to an AVRIf.
  AVRBranchIR *ABranch;

  /// ThenChildren - The block of AVRs to be moved to AVRIf's ThenChildren.
  AvrBlock *ThenChildren;

  /// ElseChildren - The block of AVRs to be moved to AVRIf's ElseChildren.
  AvrBlock *ElseChildren;

  /// ShortCircuitParent - When CandidateIf is inside a short circuit chain,
  /// this points to the topmost if parent in the sc-chain.
  CandidateIf *ShortCircuitParent; 

  /// ShortCircuitSuccessor - The AVRBranch which points to the outer most
  /// short-circuit if-chain else block.
  AVRBranch *ShortCircuitSuccessor;

public:

  CandidateIf(AVRBranchIR *AB, AvrBlock *ThenB, AvrBlock *ElseB,
              CandidateIf *SCParent, AVRBranch *SCBranch) : ABranch(AB),
              ThenChildren(ThenB), ElseChildren(ElseB),
              ShortCircuitParent(SCParent), ShortCircuitSuccessor(SCBranch) {}
  ~CandidateIf() {}

  /// \brief Sets the AvrBlock for AvrIf's ThenChildren.
  void setThenChildren(AvrBlock * IfThen) { ThenChildren = IfThen; }

  /// \brief Sets the AvrBlock for AvrIf's ElseChildren.
  void setElseChildren(AvrBlock * IfElse) { ElseChildren = IfElse; }

  /// \brief Sets the Short Circuit Parent CandidateIf of the SC-chain.
  void setShortCircuitParent(CandidateIf * SCParent)
    { ShortCircuitParent = SCParent; }

  /// \brief Sets the ShortCircuitSuccessor of the SC-chain.
  void setShortCircuitSuccessor(AVRBranch *SCSucc)
    { ShortCircuitSuccessor = SCSucc; }

  /// \brief Returns the conditional AVRBranch for CandidateIf.
  AVRBranchIR *getAvrBranch() { return ABranch; }

  /// \brief Returns the first avr of the ThenChildren AvrBlock.
  AVR *getThenBegin() { return ThenChildren->getBegin(); }

  /// \brief Returns the last avr of the ThenChildren AvrBlock.
  AVR *getThenEnd() { return ThenChildren->getEnd(); }

  /// \brief Returns the first avr of the ElseChildren AvrBlock.
  AVR *getElseBegin() { return ElseChildren->getBegin(); }

  /// \brief Returns the last avr of the ElseChildren AvrBlock.
  AVR *getElseEnd() { return ElseChildren->getEnd(); }

  /// \brief Returns true if Candidate If has 'else' block
  bool hasThenBlock() const { return ThenChildren != nullptr; }

  /// \brief Returns true if Candidate If has 'else' block
  bool hasElseBlock() const { return ElseChildren != nullptr; }

  /// \brief Returns true if CandidateIf is a child of a SC-chain.
  bool hasShortCircuit() const { return ShortCircuitSuccessor != nullptr; }

  /// brief Returns ShortCircuitSuccessor.
  AVRBranch *getShortCircuitSuccessor() { return ShortCircuitSuccessor; }
};


} // End VPO Vectorizer Namespace
} // End LLVM Namespace

#endif // LLVM_ANALYSIS_VPO_AVR_GENERATE_H
